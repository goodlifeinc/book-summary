# The Clean Coder: A Code of Conduct for Professional Programmers by Robert C. Martin

[Chapter 1: Professionalism](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-1-professionalism)

[Chapter 2: Saying No](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-2-saying-no)

[Chapter 3: Saying Yes](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-3-saying-yes)

[Chapter 5: Test Driven Development](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-4-coding)

[Chapter 6: Practicing](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-6-practicing)

[Chapter 7: Acceptance Testing](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-7-acceptance-testing)

[Chapter 8: Testing Strategies](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-8-testing-strategies)

[Chapter 9: Time Management](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-9-time-management)

[Chapter 10: Estimation](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-10-estimation)

[Chapter 11: Pressure](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-11-pressure)

[Chapter 12: Collaboration](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-12-collaboration)

[Chapter 13: Teams and Projects](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-13-teams-and-projects)

[Chapter 14: Mentoring, Apprenticeship and Craftsmanship](https://github.com/lusavova/book-summary/tree/master/The%20Clean%20Coder%20-%20Robert%20Martin#chapter-14-mentoring-apprenticeship-and-craftsmanship)


## Chapter 1: Professionalism

1. Professionalism

    :exclamation: **Professionalism is all about taking responsibility.**

    If a nonprofessional makes an error, the employer cleans up the mess. :shit: But when a professional makes a mistake, he cleans up the mess.

2. Do not create bugs :bug:

    If we want to be professionals, we must not create bugs. Writing perfect software is virtually impossible, but that doesn't mean you aren’t responsible for the imperfection.

3. Learn to apologize

     **Apologies are necessary**, but insufficient. You cannot keep making the same errors over and over. As you mature in your profession, you error rate should rapidly decrease towards the asymptote of zero.

4. Do not release faulty code to the QAs

    When you release your software its unprofessional to purposely send code that you know to be faulty and expect the QAs to find problems. And faulty code is any code you aren’t certain about!

    **QAs ARE NOT the bug catchers.** They will probably find bugs, so get ready to apologize and then figure out why those bugs managed to escape your notice and do something to prevent it from happening again.

5. Test your code

    :exclamation: **TEST YOUR CODE so that you know it works!** :exclamation: Automate your tests. Write unit tests that you can execute on a moment’s notice, and run those tests as often as you can. The test coverage have to be 100%  :100: :exclamation:

    Sometimes code is hard to test, but  thats only because it has been designed that way. So the solution is to design your code so it would be easy to test and the best way to do that is to write your tests first, before you write the code that passes them (Test Driven Development).

6. Make your code flexible

    The structure of your code that allows it to be flexible. Never compromise it :exclamation:

    Change your code all the time! Every time you look at a module you make small, lightweight changes to it to improve its structure. Every time you read through the code you adjust the structure.

7. Work ethic

    :pushpin: **Your career is your responsibility.** It is not your employer’s responsibility to make sure you are marketable, to train you, to send you to conferences, to buy you books, or to give you the time you need to learn. 

    Learn as much as possible. **Work 60 hours per week.** The first 40 for your employer and the remaining 20 for you. During this 20 hours you should be reading, practicing, learning, and otherwise enhancing your career. :heavy_exclamation_mark:
    
8. Know your field

    If you want to be a professional, you should know a sizable chunk of your field and constantly be increasing the size of that chunk.

    :memo: Things every developer should know:
    - *design patterns*
    - *design principles*
    - *methods* -> XP, Scrum, Lean, Kanban, Waterfall, Structured Analysis, and Structured Design
    - *disciplines* -> TDD, Object-Oriented design, Structured Programming, Continuous Integration, and Pair Programming.
    - *artifacts* -> UML, DFDs, Structure Charts, Petri Nets, State Transition Diagrams and Tables, flow charts, and decision tables.

    :pushpin **Read books, articles, blogs, tweets. Go to conferences. Go to user groups. Participate in reading and study groups. Learn things that are outside your comfort zone.**

9. Practice 

    **Exercise your skills outside of the performance of your job for the sole purpose of refining and enhancing those skills.** :exclamation:
    
10. Know your domain

    It is the responsibility of every software professional to **understand the domain** of the solutions they are programming.

11. Identify with your employer/customer

    Your employer’s problems are your problems. You need to understand what those problems are and work toward the best solutions. As you develop a system you need to put yourself in your employer’s shoes and make sure that the features you are developing are really going to address your employer’s needs.

## Chapter 2: Saying No

1. Learn to say NO :loudspeaker:

    **Professionals speak truth to power. Professionals have the courage to say NO to their managers.**

    Professionals are expected to say no. Good managers crave someone who has the guts to say no. It’s the only way you can really get anything done.

2. Why is less important than the fact

    *Why* is a lot less important than the fact. Still, knowing *why* might help your manager to understand, and therefore to accept, the fact.

3. High stakes

    The most important time to say NO is when the stakes are highest. The higher the stakes, the more valuable no becomes.

4. Team player :punch:

    Being a team player means playing your position as well as you possibly can, and helping out your teammates when they get into a jam. A team-player communicates frequently, keeps an eye out for his or her teammates, and executes his or her own responsibilities as well as possible. :pencil2: **But team player is not someone who says yes all the time.**

5. Never say "I will try" :x:

    **There is no trying** :heavy_exclamation_mark:

    If there is extra effort you could apply, then you must not have been applying all your effort before. When you promise to try you admit that you’ve been holding back before and there is an extra effort that you can apply. This puts the burden on you. If your “trying” does not lead to the desired outcome, you will have failed.

    When you promise you'll try you are saying that you have a new plan.

    If you are not holding back extra energy in reserve and you don’t have a new plan, if you aren’t going to change your behavior, and if you are reasonably confident in your original estimate, then promising to try is fundamentally dishonest. :boom: **You are lying**. And you are probably doing it to save face and to avoid a confrontation. :poop:

## Chapter 3: Saying Yes

1. **Say. Mean. Do.**

    Making a commitment:
    1. **Say you’ll do it.**
    2. **Mean it.**
    3. **Actually do it.**

    There are very few people who, when they say something, they mean it and then actually get it done. There are some who will say things and mean them, but they never get it done. And there are far more people who promise things and don’t even mean to do them.

2. Recognizing lack of commitment

    Signs of noncommitment: :poop:
    - *Need\should.* “We need to get this done.” “I need to lose weight.” “Someone should make that happen.”
    - *Hope\wish.* “I hope to get this done by tomorrow.” “I hope we can meet again some day.” “I wish I had time for that.” “I wish this computer was faster.”
    - *Let’s.* (not followed by “I . . .”) “Let’s meet sometime.” “Let’s finish this thing.”

3. What does commitment sound like? :memo:

    Look for sentences that sound like: **I will ... by ...** (example: I will finish this by Tuesday.)

    When you use it and you say you'll do something there is only a binary result is possible - you either get it done, or you don’t. If you don’t get it done, people can hold you up to your promises. You will feel bad about not doing it. You will feel awkward telling someone about not having done it (if that someone heard you promise you will).

    :heavy_exclamation_mark: **IMPORTANT: ALWAYS commit to things that you have full control of!**
    
    If the end goal depends on someone else, you should commit to specific actions that bring you closer to the end goal.

    If you can’t make your commitment, the most important thing is to raise a red
    flag :triangular_flag_on_post: as soon as possible to whoever you committed to. If you don’t tell anyone about the potential problem as soon as possible, you’re not giving anyone a chance to help you follow through on your commitment.

4. Learn how to say yes

    Professionals are not required to say yes to everything that is asked of them. However, they should work hard to find creative ways to make “yes” possible. 
    
    When professionals say yes, they use the language of commitment so that there is no doubt about what they’ve promised.

## Chapter 4: Coding


## Chapter 5: Test Driven Development

1. The three laws od TDD:

    - You are not allowed to write any production code until you have first written a failing unit test.

    - You are not allowed to write more of a unit test than is sufficient to fail—and not compiling is failing.
    
    - You are not allowed to write more production code that is sufficient to pass the currently failing unit test.

    :pencil2: :notebook:
    You begin by writing a small portion of a unit test. But within a few seconds you must mention the name of some class or function you have not written yet, thereby causing the unit test to fail to compile. So you must write production code that makes the test compile. But you can’t write any more than that, so you start writing more unit test code.

    Having suite of tests that you trust remove all the fear of making changes. When you see bad code, you simply clean it on the spot.

2. Documentation

    The unit tests you write when you follow the three laws is an example, written in code, describing how the system should be used. If you follow the three laws, then there will be a unit test that describes how to create every object in the system, every way that those objects can be created. There will be a unit test that describes how to call every function in the system every way that those functions can meaningfully be called. For anything you need to know how to do, there will be a unit test that describes it in detail.

    :pushpin: **The unit tests are documents.** They describe the lowest-level design of the system. They are unambiguous, accurate, written in a language that the audience understands, and are so formal that they execute. **They are the best kind of low-level documentation that can exist.**

    There are times when following the three laws is simply impractical or inappropriate. These situations are rare, but they exist. No professional developer should ever follow a discipline when that discipline does more harm than good.

## Chapter 6: Practicing

1. Practice Makes Perfect

    Practicing is very important! 

    There are lots of ways to improve your skills - you can repeat simple exercises over and over again to train your brain and fingers how to move and react, pair-programming , contributing to an open source projects, learning  new languages, reading books. :books: 

## Chapter 7: Acceptance testing

1. Acceptance tests definition
    
    Acceptance tests are  tests written by a collaboration of the stakeholders and the programmers in order to define when a requirement is done.
    
    Acceptance tests are written by the business for the business. They are formal requirements documents that specify how the system should behave from the business’ point of view. The audience is the business and the programmers.

2. Definition of Done

    **Professional developers definition of done: Done means all code written, all tests pass, QA and the stakeholders have accepted!**

3. Purpose of acceptance tests

    The purpose of acceptance tests is communication, clarity, and precision. By agreeing to them, the developers, stakeholders, and testers all understand what the plan for the system behavior is. 

    :pencil2: Your job to help your team create the best software they can. That means that everybody needs to watch out for errors and slip-ups, and work together to correct them.

    The primary purpose of unit tests and acceptance tests is to formally document the design, structure, and behavior of the system. The fact that they automatically verify the design, structure, and behavior that they specify is wildly useful, but the specification is their true purpose.

4. Continuous integration
    
    All unit- and acceptance tests are run several times per day in a continuous integration system. This system should be triggered by the source code control system. Every time someone commits a module, the CI system should kick off a build, and then run all the tests in the system.

## Chapter 8: Testing strategies

1. The Test Automation Pyramid

- Unit tests

    Tests written by programmers, for programmers, in the programming language of the system. 
    
    Their intent is to specify the system at the lowest level. 
    
    They are written before writing production code as a way to specify what the purpose of the code. They are executed as part of Continuous Integration to ensure that the intent of the programmers’ is upheld. 
    
    Unit tests provide as close to 100% coverage. :100: :heavy_exclamation_mark:

- Component Tests

    Component test wraps a component. It passes input data into the component and gathers output data from it. It tests that the output matches the input. Any other system components are decoupled from the test using appropriate mocking and test-doubling techniques.

    Component tests are written by QA and Business with assistance from development.

    They cover roughly half the system and are directed more towards happy-path situations and very obvious corner, boundary, and alternate-path cases.

- Integration Tests

    Integration tests assemble groups of components and test how well they communicate with each other. The other components of the system are decoupled as usual with appropriate mocks and test-doubles.

    Integration tests do not test business rules. Rather, they test how well the assembly of components dances together. 
    
    They make sure that components are properly connected and can clearly communicate with each other.

    They are typically written by the system architects, or lead designers. 
    
    The tests ensure that the architectural structure of the system is sound. They are typically not executed as part of the Continuous Integration suite, because they often have longer runtimes. Instead, these tests are run periodically (nightly, weekly, etc.) as deemed necessary by their authors.

- System Tests

    These are automated tests that execute against the entire integrated system. They are the ultimate integration tests. 
    
    They do not test business rules directly. Rather, they test that the system has been wired together correctly and its parts interoperate according to plan.
    
    These tests are written by the system architects and technical leads.
    
    System tests cover perhaps 10% of the system. Their intent is not to ensure correct system behavior, but correct system construction.

- Manual Explor Atory Tests

    These tests are not automated, nor are they scripted. The intent of these tests is to explore the system for unexpected behaviors while confirming expected behaviors.

## Chapter 9: Time management

1. Meetings
    
    Attending to too many meetings is a huge time waster and because you are responsible for managing your own time it can be a huge problem.
    
    You don't have to attend every meeting to which you are invited. **Use your time wisely** and be very careful about which meetings you attend and which you politely refuse. :heavy_exclamation_mark:

    Accept only meetings  which your participation is immediately and significantly necessary to the job you are doing now.

    If you find yourself stuck in a meeting that is not a good use of your time, you need to find a way to politely exit that meeting.

2.  Sleep :zzz:

    Sleep is extremely important. :clock10: Get seven-eight hours of sleep every night. :clock6: It helps your concentration massively.

3. Recharging

    A good long walk :walking:, a conversation with friends :dog: , a time of just looking out a window :sunrise_over_mountains: can all help to pump the focus-manna back up. Once the manna is gone, you can’t force the focus. You can still write code, but you’ll almost certainly have to rewrite it the next day, or live with a rotting mass :poop: for weeks or months. So it’s better to take thirty, or even sixty minutes to de-focus.

4. Muscle focus :muscle:

    **Muscle focus helps to recharge mental focus.**

    It’s more than a simple recharge. A regular regimen of muscle focus increases the capacity for mental focus. :muscle:

5. Pomodoro technique :tomato:

    Your time is divided into tomato :tomato: and non-tomato time. Tomato time is productive. It is within tomatoes that you get real work done. Time outside of tomatoes is either distractions, meetings, breaks, or other time that is not spent working on your tasks.

## Chapter 10: Estimation

 1. Estimation

    Business likes to view estimates as commitments. Developers like to view estimates as guesses.

2. Commitment 

    **A commitment is something you must achieve.** If you commit to getting something done by a certain date, then you simply have to get it done by that date. If that means you have to work 12 hours a day, on weekends, skipping family vacations, then so be it.

    **Professionals don’t make commitments unless they know they can achieve them.**

    **If you are asked to commit to something that you aren’t certain you can do, then you are honor bound to decline.** :heavy_exclamation_mark:

    If you are asked to commit to a date that you know you can achieve, but would require long hours, weekends, and skipped family vacations, then the choice is yours; but you’d better be willing to do what it takes.

    Commitment is about certainty. Other people are going to accept your commitments and make plans based upon them. **Missing a commitment is an act of dishonesty only slightly less onerous than an overt lie.**

3. An estimate
    
    An estimate is a guess. No commitment is implied. No promise is made. Missing an estimate is not in any way dishonorable.
    
    Unfortunately, most software developers are terrible estimators. The reason we are often so bad at estimating is because we don’t understand the true nature of an estimate. An estimate is not a number. An estimate is a distribution.

4. Estimating tasks
    
    **The most important estimation resource you have are the people around you.** They can see things that you don’t. They can help you estimate your tasks more accurately than you can estimate them on your own.

    **Breaking large tasks into small ones and estimating the small ones independently is a good technique.** Some errors do integrate out, and breaking the tasks up is a good way to understand those tasks better and uncover surprises.

## Chapter 11: Pressure

1. Avoid situations that cause pressure

    The professional developer is calm and decisive under pressure. As the pressure grows he adheres to his training and disciplines, knowing that they are the best way to meet the deadlines and commitments that are pressing on him.

    The best way to stay calm under pressure is to avoid the situations that cause pressure.

2. Commitment
    
    **It is important to avoid committing to deadlines that we aren’t sure we can meet.**

    The business will always want these commitments because they want to eliminate risk. What we must do is make sure that the risk is quantified and presented to the business so that they can manage it appropriately. 

3. Stay clean

    **The way to go fast, and to keep the deadlines at bay, is to stay clean.** Professionals do not succumb to the temptation to create a mess in order to move quickly. Professionals realize that “quick and dirty” is an oxymoron. **Dirty always means slow!**

    **We can avoid pressure by keeping our systems, our code, and our design as clean as possible.**
    
    If you follow the discipline of Test Driven Development in noncrisis times but abandon it during a crisis, then you don’t really trust that TDD is helpful. If you keep your code clean during normal times but make messes in a crisis, then you don’t really believe that messes slow you down. If you pair in a crisis but don’t normally pair, then you believe pairing is more efficient than non-pairing.

    **Choose disciplines that you feel comfortable following in a crisis.** Then follow them all the time. Following these disciplines is the best way to avoid getting into a crisis. Don’t change your behavior when the crunch comes. If your disciplines are the best way to work, then they should be followed even in the depths of a crisis.

4. Manage stress 
    
    Manage your stress. Sleepless nights won’t help you get done any faster. Sitting and fretting won’t help either. And the worst thing you could do is to rush! Resist that temptation at all costs. Rushing will only drive you deeper into the hole.
    
    Instead, slow down. Think the problem through. Plot a course to the best possible outcome, and then drive towards that outcome at a reasonable and steady pace.

5. Inform your team

    Let your team and your superiors know that you are in trouble. Tell them your best plans for getting out of trouble. Ask them for their input and guidance. Avoid creating surprises. Nothing makes people more angry and less rational than surprises.

6. Fllow your chosen disciplines

    If you follow TDD, then write even more tests than usual. If you are a merciless refactorer, then refactor even more. If you keep your functions small, then keep them even smaller. The only way through the pressure cooker is to rely on what you already know works - your disciplines.

## Chapter 12: Collaboration :couple:

1. Understand the business

    Professional programmers take the time to understand the business. They talk to users about the software they are using. They talk to sales and marketing people about the problems and issues they have. They talk to their managers to understand the short- and long-term goals of the team. In short, they **pay attention to the ship they are sailing on.**

2. Pairing

    **Pair programming is clearly the most efficient way to solve the problem.** All professionals pair. That's because it is the best way to share knowledge with each other. Professionals don’t create knowledge silos. Rather, they learn the different parts of the system and business by pairing with each other. They recognize that although all team members have a position to play, all team members should also be able play another position in a pinch.

    Professionals pair because it is the best way to review code. No system should consist of code that hasn’t been reviewed by other programmers. There are many ways to conduct code reviews; most of them are horrifically inefficient. The most efficient and effective way to review code is to collaborate in writing it.

    Professionals work together. You can’t work together while you are sitting in corners wearing headphones. So sitt around tables facing each other. Be able to smell each other’s fear. Be able to overhear someone’s frustrated mutterings. Communicate as a unit.

## Chapter 13: Teams and Projects

1. Teams

    It take time for a team to form. The team members start to form relationships. They learn how to collaborate with each other. They learn each other’s quirks, strengths, and weaknesses. Eventually the team begins to gel. There is something truly magical about a gelled team. They can work miracles. They anticipate each other, cover for each other, support each other, and demand the best from each other. They make things happen.

    It takes time for a team like this to work out their differences, come to terms with each other, and really gel. It might take six months. It might even take a year. But once it happens, it’s magic. A gelled team will plan together, solve problems together, face issues together, and get things done. Once this happens, it is ludicrous to break it apart just because a project comes to an end. It’s best to keep that team together and just keep feeding it projects.

2. Projects

    Banks and insurance companies tried to form teams around projects. This is a foolish approach. The teams simply cannot gel. The individuals are only on the project for a short time, and only for a percentage of their time, and therefore never learn how to deal with each other.

    Professional development organizations allocate projects to existing gelled teams, they don’t form teams around projects. A gelled team can accept many projects simultaneously and will divvy up the work according to their own opinions, skills, and abilities. The gelled team will get the projects done.

    Teams are harder to build than projects. Therefore, it is better to form persistent teams that move together from one project to the next and can take on more than one project at a time. The goal in forming a team is to give that team enough time to gel, and then keep it together as an engine for getting many projects done.

## Chapter 14: Mentoring, Apprenticeship, and Craftsmanship

1. Mentoring
    
    There are different kinds of mentoring. You can learn simply from the authors of a very well-written manual, or by observing people and many more different ways.

2. Craftmanship

    A craftsman is someone who works quickly, but without rushing, who provides reasonable estimates and meets commitments. A craftsman knows when to say no, but tries hard to say yes. A craftsman is a professional.

    Craftsmanship is the mindset held by craftsmen. Craftsmanship is a meme that contains values, disciplines, techniques, attitudes, and answers.

    The craftsmanship meme is handed from one person to another. It is taught by elders to the young. It is exchanged between peers. It is observed and relearned, as elders observe the young. Craftsmanship is a contagion, a kind of mental virus. You catch it by observing others and allowing the meme to take hold.