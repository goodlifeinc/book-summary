# The Clean Coder: A Code of Conduct for Professional Programmers

## Chapter 1: Professionalism

1. Professionalism

    **Professionalism is all about taking responsibility.**

    If a nonprofessional makes an error, the employer cleans up the mess. But when a professional makes a mistake, he cleans up the mess.

2. Do not create bugs

    In order to be professional, we must not create bugs. The fact that the task to write perfect software is virtually impossible does not mean you aren’t responsible for the imperfection.

3. Learn to apologize

    But first thing you must practice is apologizing. **Apologies are necessary**, but insufficient. You cannot keep making the same errors over and over. As you mature in your profession, you error rate should rapidly decrease towards the asymptote of zero.

4. Do not release faulty code to the QAs

    When you release your software its unprofessional to purposely send code that you know to be faulty and expect the QAs to find problems. And what code do you know to be faulty? Any code you aren’t certain about!

    **QAs ARE NOT the bug catchers.** But will they find bugs? Probably, so get ready to apologize and then figure out why those bugs managed to escape your notice and do something to prevent it from happening again.

5. Test your code

    How can you know your code works? That’s easy. **TEST IT!!!!** Automate your tests. Write unit tests that you can execute on a moment’s notice, and run those tests as often as you can. The test coverage have to be 100%!

    Sometimes code is hard to test. But only because that code has been designed that way. The solution to that is to design your code to be easy to test. And the best way to do that is to write your tests first, before you write the code that passes them (Test Driven Development).

6. Make your code flexible

    It is the structure of your code that allows it to be flexible. Never compromise it!!!
    Change your code all the time! Every time you look at a module you make small, lightweight changes to it to improve its structure. Every time you read through the code you adjust the structure.

7. Work ethic

    **Your career is your responsibility.** It is not your employer’s responsibility to make sure you are marketable.It is not your employer’s responsibility to train you, or to send you to conferences, or to buy you books.

    It is also not your employer’s responsibility to give you the time you need to learn. 

    Work 60 hours per week. The first 40 are for your employer. The remaining 20 are for you. During this remaining 20 hours you should be reading, practicing, learning, and otherwise enhancing your career.
    
8. Know your field

    If you want to be a professional, you should know a sizable chunk of your field and constantly be increasing the size of that chunk.

    Things every developer should know:
    - design patterns
    - design principles
    - methods -> XP, Scrum, Lean, Kanban, Waterfall, Structured Analysis, and Structured Design
    - disciplines -> TDD, Object-Oriented design, Structured Programming, Continuous Integration, and Pair Programming.
    - artifacts -> UML, DFDs, Structure Charts, Petri Nets, State Transition Diagrams and Tables, flow charts, and decision tables.

    **Read books, articles, blogs, tweets. Go to conferences. Go to user groups. Participate in reading and study groups. Learn things that are outside your comfort zone.** If you are a .NET programmer, learn Java. If you are a Java programmer, learn Ruby. If you are a C programmer, learn Lisp. If you want to really bend your brain, learn Prolog and Forth

9. Practice 

    **Exercise your skills outside of the performance of your job for the sole purpose of refining and enhancing those skills.**
    
10. Know your domain

    It is the responsibility of every software professional to **understand the domain** of the solutions they are programming.

11. Identify with your employer/customer

    Your employer’s problems are your problems. You need to understand what those problems are and work toward the best solutions. As you develop a system you need to put yourself in your employer’s shoes and make sure that the features you are developing are really going to address your employer’s needs.

**Remember:**
- take responsibility
- be ready to apologies
- NEVER ship without testing!
- QA should find nothing wrong with your code
- test your code (100% test coverage)
- adjust the structure of your code every time you read through it
- work 60 hours per week
- know your field
- practice - train your fingers and your brain with solving simple problems
- know your domain

## Chapter 2: Saying No

1. Learn to say NO

    **Professionals speak truth to power. Professionals have the courage to say NO to their managers.**

    Slaves are not allowed to say no. Laborers may be hesitant to say no. But professionals are expected to say no. Indeed, good managers crave someone who has the guts to say no. It’s the only way you can really get anything done.

    The hard decisions are best made through the confrontation of adversarial roles.

2. Why is less important than the fact

    The why is a lot less important than the fact. Still, knowing why might help your manager to understand, and therefore to accept, the fact.

3. High stakes

    The most important time to say no is when the stakes are highest. The higher the stakes, the more valuable no becomes.

4. Team player

    Being a team player means playing your position as well as you possibly can, and helping out your teammates when they get into a jam. A team-player communicates frequently, keeps an eye out for his or her teammates, and executes his or her own responsibilities as well as possible. A team player is not someone who says yes all the time.

5. Never say "I will try"

    **There is no trying.**
    If there is extra effort she could apply, then you must not have been applying all your effort before. The promise to try is an admission that you’ve been holding back, that you have a reservoir of extra effort that you can apply. This puts the burden on you. If your “trying” does not lead to the desired outcome, you will have failed.

    By promising to try you are saying that you have a new plan. If you don’t have a new plan, if you don’t make a change to your behavior, if you do everything exactly as you would have before you promised to “try,” then what does trying mean?

    If you are not holding back some energy in reserve, if you don’t have a new plan, if you aren’t going to change your behavior, and if you are reasonably confident in your original estimate, then promising to try is fundamentally dishonest. You are lying. And you are probably doing it to save face and to avoid a confrontation.

**Remember:**
- professionals have the courage to say NO
- the time to say no is when the stakes are highest
- team player is not someone who says yes all the time
- trying actually means lying

## Chapter 3: Saying Yes

1. **Say. Mean. Do.**

    There are three parts to making a commitment.
    1. **You say you’ll do it.**
    2. **You mean it.**
    3. **You actually do it.**

    There are very few people who, when they say something, they mean it and then actually get it done. There are some who will say things and mean them, but they never get it done. And there are far more people who promise things and don’t even mean to do them.

    Ever heard someone say, “Man, I really need to lose some weight,” and you knew they are not going to do anything about it? It happens all the time.

    Instead of trusting our guts, we can use some language-related tricks to try and figure out if people really mean what they say. And by changing what we say, we can start taking care of steps 1 and 2 of the previous list on our own. When we say we will commit to something, and we need to mean it.

2. Recognizing lack of commitment

    Signs of noncommitment:
    - *Need\should.* “We need to get this done.” “I need to lose weight.” “Someone should make that happen.”
    - *Hope\wish.* “I hope to get this done by tomorrow.” “I hope we can meet again some day.” “I wish I had time for that.” “I wish this computer was faster.”
    - *Let’s.* (not followed by “I . . .”) “Let’s meet sometime.” “Let’s finish this thing.”

3. What does commitment sound like?

    The secret ingredient to recognizing real commitment is to look for sentences that sound like this: **I will ... by ...** (example: I will finish this by Tuesday.)

    When you use it and you say you'll do something there is only a binary result is possible - you either get it done, or you don’t. If you don’t get it done, people can hold you up to your promises. You will feel bad about not doing it. You will feel awkward telling someone about not having done it (if that someone heard you promise you will).

    Something very important is to ALWAYS commit to things that you have full control of.
    If the end goal depends on someone else, you should commit to specific actions that bring you closer to the end goal.

    If you can’t make your commitment, the most important thing is to raise a red
    flag as soon as possible to whoever you committed to. If you don’t tell anyone about the potential problem as soon as possible, you’re not giving anyone a chance to help you follow through on your commitment.

4. Learn how to say yes

    Professionals are not required to say yes to everything that is asked of them. However, they should work hard to find creative ways to make “yes” possible. When professionals say yes, they use the language of commitment so that there is no doubt about what they’ve promised.

**Remember:**
- Say. Mean. Do.
- always commit to things that you have full controll of
- if you can's make your commitment, inform the person or people whoever you committed to as soon as possible

## Chapter 4: Coding


## Chapter 5: Test Driven Development

1. The three laws od TDD:

    - You are not allowed to write any production code until you have first written a failing unit test.
    - You are not allowed to write more of a unit test than is sufficient to fail—and not compiling is failing.
    - You are not allowed to write more production code that is sufficient to pass the currently failing unit test.

    You begin by writing a small portion of a unit test. But within a few seconds you must mention the name of some class or function you have not written yet, thereby causing the unit test to fail to compile. So you must write production code that makes the test compile. But you can’t write any more than that, so you start writing more unit test code.

    When you have a suite of tests that you trust, then you lose all fear of making changes. When you see bad code, you simply clean it on the spot.

2. Documentation

    Each of the unit tests you write when you follow the three laws is an example, written in code, describing how the system should be used. If you follow the three laws, then there will be a unit test that describes how to create every object in the system, every way that those objects can be created. There will be a unit test that describes how to call every function in the system every way that those functions can meaningfully be called. For anything you need to know how to do, there will be a unit test that describes it in detail.

    **The unit tests are documents.** They describe the lowest-level design of the system. They are unambiguous, accurate, written in a language that the audience understands, and are so formal that they execute. **They are the best kind of low-level documentation that can exist.**

3. Sometimes TDD does't work

    But there are times when following the three laws is simply impractical or inappropriate. These situations are rare, but they exist. No professional developer should ever follow a discipline when that discipline does more harm than good.

**Remember:**
- test driven development makes your code cleaner and more flexible 
- unit tests are documentation

## Chapter 6: Practicing

1. Practice makes perfect

    Practicing is very important! 
    There are lots of ways to improve your skills. You can repeat simple exercises over and over again to train your brain and fingers how to move and react. As you practice you may descover subtle improvements and effeciencies either in your motions or in the solution itself. 

    Other good ways is pair-programming or contributing to an open source projects. Learn new languages, contribute to projects constantly, read books ... PRACTICE! 

## Chapter 7: Acceptance testing

1. Acceptance tests definition
    
    Acceptance tests are  tests written by a collaboration of the stakeholders and the programmers in order to define when a requirement is done.

2. Definition of Done

    **Professional developers definition of done: Done means all code written, all tests pass, QA and the stakeholders have accepted!**

3. Purpose of acceptance tests
    The purpose of acceptance tests is communication, clarity, and precision. By agreeing to them, the developers, stakeholders, and testers all understand what the plan for the system behavior is. 

    As a professional it is your job to help your team create the best software they can. That means that everybody needs to watch out for errors and slip-ups, and work together to correct them.

    Acceptance tests are written by the business for the business. They are formal requirements documents that specify how the system should behave from the business’ point of view. The audience is the business and the programmers.

    Unit tests and acceptance tests are documents first, and tests second. Their primary purpose is to formally document the design, structure, and behavior of the system. The fact that they automatically verify the design, structure, and behavior that they specify is wildly useful, but the specification is their true purpose.

4. Continuous integration
    
    All unit tests and acceptance tests are run several times per day in a continuous integration system. This system should be triggered by the source code control system. Every time someone commits a module, the CI system should kick off a build, and then run all the tests in the system.

## Chapter 8: Testing strategies

1. The test automation pyramid

- Unit tests
    These tests are written by programmers, for programmers, in the programming language of the system. The intent of these tests is to specify the system at the lowest level. Developers write these tests before writing production code as a way to specify what they are about to write. They are executed as part of Continuous Integration to ensure that the intent of the programmers’ is upheld. Unit tests provide as close to 100% coverage as is practical.

- Component tests

    Component test wraps a component. It passes input data into the component and gathers output data from it. It tests that the output matches the input. Any other system components are decoupled from the test using appropriate mocking and test-doubling techniques.

    Component tests are written by QA and Business with assistance from development.
    Component tests cover roughly half the system. They are directed more towards happy-path situations and very obvious corner, boundary, and alternate-path cases.

- Integration tests

    Integration tests assemble groups of components and test how well they communicate with each other. The other components of the system are decoupled as usual with appropriate mocks and test-doubles.

    Integration tests are choreography tests. They do not test business rules. Rather, they test how well the assembly of components dances together. They are plumbing tests that make sure that the components are properly connected and can clearly communicate with each other.

    Integration tests are typically written by the system architects, or lead designers, of the system. The tests ensure that the architectural structure of the system is sound. They are typically not executed as part of the Continuous Integration suite, because they often have longer runtimes. Instead, these tests are run periodically (nightly, weekly, etc.) as deemed necessary by their authors.

- System tests

    These are automated tests that execute against the entire integrated system. They are the ultimate integration tests. They do not test business rules directly. Rather, they test that the system has been wired together correctly and its parts interoperate according to plan.
    
    These tests are written by the system architects and technical leads. System tests cover perhaps 10% of the system. This is because their intent is not to ensure correct system behavior, but correct system construction.

- Manual explor atory tests

    These tests are not automated, nor are they scripted. The intent of these tests is to explore the system for unexpected behaviors while confirming expected behaviors.

## Chapter 9: Time management

1. Meetings

    You are responsible for managing your own time. Having too many meetings is a huge time waster, so you don't have to attend every meeting to which you are invited. **Use your time wisely**. So be very careful about which meetings you attend and which you politely refuse.

    When you receive a meeting invitation, don’t accept unless it is a meeting for which your participation is immediately and significantly necessary to the job you are doing now.

    If you find yourself stuck in a meeting that is not a good use of your time, you need to find a way to politely exit that meeting.

2.  Sleep 

    Sleep is extremely important. Get seven-eight hours of sleep every night. It helps your concentration massively.

3. Recharging

    A good long walk, a conversation with friends, a time of just looking out a window can all help to pump the focus-manna back up. Once the manna is gone, you can’t force the focus. You can still write code, but you’ll almost certainly have to rewrite it the next day, or live with a rotting mass for weeks or months. So it’s better to take thirty, or even sixty minutes to de-focus.

4. Muscle focus

    **Muscle focus helps to recharge mental focus.**

    It’s more than a simple recharge. A regular regimen of muscle focus increases the capacity for mental focus.

5. Pomodoro technique

    Your time is divided into tomato and non-tomato time. Tomato time is productive. It is within tomatoes that you get real work done. Time outside of tomatoes is either distractions, meetings, breaks, or other time that is not spent working on your tasks.

## Chapter 10: Estimation

 1. Estimation

    Business likes to view estimates as commitments. Developers like to view estimates as guesses.

2. Commitment 

    **A commitment is something you must achieve.** If you commit to getting something done by a certain date, then you simply have to get it done by that date. If that means you have to work 12 hours a day, on weekends, skipping family vacations, then so be it.

    **Professionals don’t make commitments unless they know they can achieve them.**

    **If you are asked to commit to something that you aren’t certain you can do, then you are honor bound to decline.**

    If you are asked to commit to a date that you know you can achieve, but would require long hours, weekends, and skipped family vacations, then the choice is yours; but you’d better be willing to do what it takes.

    Commitment is about certainty. Other people are going to accept your commitments and make plans based upon them. **Missing a commitment is an act of dishonesty only slightly less onerous than an overt lie.**

3. An estimate
    
    An estimate is a guess. No commitment is implied. No promise is made. Missing an estimate is not in any way dishonorable.
    
    Unfortunately, most software developers are terrible estimators. The reason we are often so bad at estimating is because we don’t understand the true nature of an estimate. An estimate is not a number. An estimate is a distribution.

4. Estimating tasks
    
    **The most important estimation resource you have are the people around you.** They can see things that you don’t. They can help you estimate your tasks more accurately than you can estimate them on your own.

    **Breaking large tasks into small ones and estimating the small ones independently is a good technique.** Some errors do integrate out, and breaking the tasks up is a good way to understand those tasks better and uncover surprises.

## Chapter 11: Pressure

1. Avoid situations that cause pressure

    The professional developer is calm and decisive under pressure. As the pressure grows he adheres to his training and disciplines, knowing that they are the best way to meet the deadlines and commitments that are pressing on him.

    The best way to stay calm under pressure is to avoid the situations that cause pressure.

2. Commitment
    
    **It is important to avoid committing to deadlines that we aren’t sure we can meet.**

    The business will always want these commitments because they want to eliminate risk. What we must do is make sure that the risk is quantified and presented to the business so that they can manage it appropriately. 

3. Stay clean

    **The way to go fast, and to keep the deadlines at bay, is to stay clean.** Professionals do not succumb to the temptation to create a mess in order to move quickly. Professionals realize that “quick and dirty” is an oxymoron. **Dirty always means slow!**

    **We can avoid pressure by keeping our systems, our code, and our design as clean as possible.**
    
    If you follow the discipline of Test Driven Development in noncrisis times but abandon it during a crisis, then you don’t really trust that TDD is helpful. If you keep your code clean during normal times but make messes in a crisis, then you don’t really believe that messes slow you down. If you pair in a crisis but don’t normally pair, then you believe pairing is more efficient than non-pairing.

    **Choose disciplines that you feel comfortable following in a crisis.** Then follow them all the time. Following these disciplines is the best way to avoid getting into a crisis. Don’t change your behavior when the crunch comes. If your disciplines are the best way to work, then they should be followed even in the depths of a crisis.

4. Manage stress 
    
    Manage your stress. Sleepless nights won’t help you get done any faster. Sitting and fretting won’t help either. And the worst thing you could do is to rush! Resist that temptation at all costs. Rushing will only drive you deeper into the hole.
    
    Instead, slow down. Think the problem through. Plot a course to the best possible outcome, and then drive towards that outcome at a reasonable and steady pace.

5. Inform your team

    Let your team and your superiors know that you are in trouble. Tell them your best plans for getting out of trouble. Ask them for their input and guidance. Avoid creating surprises. Nothing makes people more angry and less rational than surprises.

6. Fllow your chosen disciplines

    If you follow TDD, then write even more tests than usual. If you are a merciless refactorer, then refactor even more. If you keep your functions small, then keep them even smaller. The only way through the pressure cooker is to rely on what you already know works - your disciplines.

## Chapter 12: Collaboration

1. Understand the business

    Professional programmers take the time to understand the business. They talk to users about the software they are using. They talk to sales and marketing people about the problems and issues they have. They talk to their managers to understand the short- and long-term goals of the team. In short, they **pay attention to the ship they are sailing on.**

2. Pairing

    **Pair programming is clearly the most efficient way to solve the problem.** All professionals pair. That's because it is the best way to share knowledge with each other. Professionals don’t create knowledge silos. Rather, they learn the different parts of the system and business by pairing with each other. They recognize that although all team members have a position to play, all team members should also be able play another position in a pinch.

    Professionals pair because it is the best way to review code. No system should consist of code that hasn’t been reviewed by other programmers. There are many ways to conduct code reviews; most of them are horrifically inefficient. The most efficient and effective way to review code is to collaborate in writing it.

    Professionals work together. You can’t work together while you are sitting in corners wearing headphones. So sitt around tables facing each other. Be able to smell each other’s fear. Be able to overhear someone’s frustrated mutterings. Communicate as a unit.
